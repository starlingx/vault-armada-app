apiVersion: v1
data:
  init.sh: |
    #!/bin/bash

    # Get the CA path from environment vars
    CERT=$CA_CERT
    # Store cert as a oneliner for curl purposes
    CA_ONELINE=$(awk '{printf "%s\\n", $0}' $CERT)

    # Template vaules from helm
    VAULT_NS={{ .Release.Namespace }}
    VAULT_NAME={{ template "vault.name" .}}
    VAULT_FN={{ template "vault.fullname" . }}
    HA_REPLICAS={{ .Values.server.ha.replicas }}

    # Set the domain for resolving pod names
    DOMAIN="${VAULT_NS}.pod.cluster.local"
    SVCDOMAIN="${VAULT_NS}.svc.cluster.local"

    # impermanent location to store files while running
    WORKDIR=/workdir
    mkdir $WORKDIR

    # Trap and trap notification file. When SIGTERM is sent to this pod
    # we want to exit promptly and gracefully.
    TRAPFILE=$WORKDIR/exit_on_trap
    trap "touch $TRAPFILE" SIGTERM

    # Records for seal status state machine:
    PODREC_F="$WORKDIR/previous_pods_status.txt"
    PODREC_TMP_F="$WORKDIR/new_pods_status.txt"

    # Vault server health query timeout during HA recovery scenario
    QUERY_TMOUT={{ .Values.manager.healthQueryTimeout }}

    STATEFULSET_RATE=5
    INIT_CONVERGE_TIME=10
    JOIN_RATE=5
    JOIN_CONVERGE_TIME=1
    UNSEAL_RATE=10
    UNSEAL_CONVERGE_TIME=3
    STATUS_RATE={{ .Values.manager.statusCheckRate }}
    if [ -z "$STATUS_RATE" ]; then
        STATUS_RATE=5
    fi

    # with STATUS_RATE, the period to delay unseal
    # STATUS_RATE * STATEMACH_START seconds
    STATEMACH_START={{ .Values.manager.unsealWaitIntervals }}
    if [ -z "$STATEMACH_START" ]; then
        STATEMACH_START=3
    fi

    # Log levels
    DEBUG=1
    INFO=2
    WARNING=3
    ERROR=4
    FATAL=5

    # Default log level and the set log level (Initially set as default).
    # If the log function detects an override file, then it will switch
    # the set log level and then delete it.
    DEFAULT_LOG_LEVEL=$INFO
    LOG_LEVEL={{ .Values.manager.log.defaultLogLevel }}
    LOG_OVERRIDE_FILE="$WORKDIR/log_level"

    # FUNCTIONS
    function log {
        # Log level in text
        local logStr=""
        case $1 in
        $INFO)
            logStr="INFO"
            ;;
        $DEBUG)
            logStr="DEBUG"
            ;;
        $WARNING)
            logStr="WARNING"
            ;;
        $ERROR)
            logStr="ERROR"
            ;;
        $FATAL)
            logStr="FATAL"
            ;;
        esac

        # check if log override file "Exists"
        if [ -f $LOG_OVERRIDE_FILE ]; then
            local newLogLevel=$(cat $LOG_OVERRIDE_FILE)
            # validation for newLogLevel
            if [[ "$newLogLevel" =~ ^[1-5]$ ]]; then
                LOG_LEVEL=$newLogLevel
                echo "$(date +%Y-%m-%dT%H-%M-%S) DEBUG Log level set to $logStr"
            else
                echo "$(date +%Y-%m-%dT%H-%M-%S) DEBUG"\
                     "Invalid log level read from $LOG_OVERRIDE_FILE."
            fi
            rm $LOG_OVERRIDE_FILE
        fi

        # validate LOG_LEVEL. If it is not valid, then use DEFAULT_LOG_LEVEL instead.
        if [[ ! "$LOG_LEVEL" =~ ^[1-5]$ ]]; then
            echo "$(date +%Y-%m-%dT%H-%M-%S) DEBUG" \
                 "Invalid log level detected, will be set to $DEFAULT_LOG_LEVEL"
            LOG_LEVEL=$DEFAULT_LOG_LEVEL
        fi

        # check if the log level for this call is equal to or higher than the set log level
        if [ $1 -ge $LOG_LEVEL ]; then
            # print log
            echo "$(date +%Y-%m-%dT%H-%M-%S) $logStr ${@:2}"
        fi
    }

    if ! [[ "$QUERY_TMOUT" =~ ^[0-9]+$ ]]; then
        log $WARNING ".Values.manager.healthQueryTimeout not an integer"
        QUERY_TMOUT=""
    fi

    function exit_on_trap {
        local tfnum=""

        if [ -e "$TRAPFILE" ]; then
            tfnum=$(cat $TRAPFILE)
            log $DEBUG "removing $TRAPFILE"
            rm "$TRAPFILE" # for workdir on PVC
            if [ -n "$tfnum" ] && [ "$tfnum" -eq $1 ]; then
                log $DEBUG "Exit on trap SIGTERM on call $1"
                exit
            else
                log $DEBUG "tfnum of $tfnum does not match with call number $1"
            fi
        else
            log $DEBUG "exit_on_trap call $1 reached. no trapfile found"
        fi
    }

    # Creates a list of all k8s vault pods and stores in text file.
    # Converts ips from X.X.X.X or a:b:c::d to X-X-X-X for use as pod
    # dns names
    function getVaultPods {
        kubectl get pods \
        -n "$VAULT_NS" \
        -l component=server,app.kubernetes.io/name=vault \
        -o=jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.status.podIPs[].ip}{"\n"}{end}' \
        > $WORKDIR/pods.txt

        sed -i 's/\.\|:/-/g' $WORKDIR/pods.txt
    }

    # Wait for the vault servers in the stateful set to be
    # created before initializing
    function waitForPods {
        local jsonPath='{range .items[*]}{.metadata.name}{"\t"} \
        {.status.podIPs[].ip}{"\t"}{.status.phase}{"\n"} \
        {end}'

        CURRENT_PODS=$(kubectl get pods \
                    -l component=server,app.kubernetes.io/name=vault \
                    -o=jsonpath="$jsonPath" \
                    | grep Running \
                    | wc -l)
        DESIRED_PODS=$1

        if ! [[ "$CURRENT_PODS" =~ ^[0-9]+$ ]]; then
            log $ERROR "Invalid Running pod number ($CURRENT_PODS) from kubectl get pods"
            CURRENT_PODS=0
        fi

        while [ $CURRENT_PODS -lt $DESIRED_PODS ]; do
            sleep "$STATEFULSET_RATE"
            log $INFO "Waiting for ${VAULT_FN}" \
                "statefulset running pods ($CURRENT_PODS) to equal" \
                "desired pods ($DESIRED_PODS)"
            CURRENT_PODS=$(kubectl get pods \
                -l component=server,app.kubernetes.io/name=vault \
                -o=jsonpath="$jsonPath" \
                | grep Running \
                | wc -l)
        done
    }

    # Initializes the first vault pod, only needs to be performed once
    # after deploying the helm chart
    # Stores the root token and master key shards in persistent storage
    function initVault {
        local keys

        V0=$(awk 'NR==1{print $2}' $WORKDIR/pods.txt)
        log $INFO "Initializing $V0"

        keys="$(
            curl -s \
            --cacert $CERT \
            --request POST \
            --data  '{"secret_shares": 5, "secret_threshold": 3}' \
            https://$V0.$DOMAIN:8200/v1/sys/init
        )"

        set_secret cluster-key-all /dev/stdin <<<"$keys"
    }

    # Uses the master key shards to unseal vault
    function unsealVault {
        shards="$( get_secret cluster-key-all | jq -r .keys_base64[] )"
        for shard in $shards; do
            echo {\"key\": \"$shard\"} \
            | curl -s --cacert $CERT --request POST -d @- \
                https://$VAULT.$DOMAIN:8200/v1/sys/unseal > /dev/null
            #Some sleep is required to allow Raft convergence
            sleep "$UNSEAL_CONVERGE_TIME"
        done
    }

    # Takes the address of vault-0 as the cluster leader and
    # joins other nodes to raft
    function joinRaft {
        CLUSTER_LEAD=$(awk 'NR==1{print $2}' $WORKDIR/pods.txt)
        ROOT_TOKEN=$( get_secret cluster-key-all | jq -r .root_token)
        local activeLink="https://sva-$VAULT_NAME-active.$SVCDOMAIN:8200"
        local dataJson="{\"leader_api_addr\": \"$activeLink\", \"leader_ca_cert\": \"$CA_ONELINE\"}"
        RAFT_STATUS=""
        while [ "$RAFT_STATUS" != "true" ]; do
            RAFT_STATUS=$(curl -s \
                --cacert $CERT \
                -H "X-Vault-Token: $ROOT_TOKEN" \
                --request POST \
                --data "$dataJson" \
                https://$row.$DOMAIN:8200/v1/sys/storage/raft/join)

            log $INFO "$row $RAFT_STATUS"
            RAFT_STATUS=$(echo $RAFT_STATUS | jq -r .joined)
            sleep "$JOIN_CONVERGE_TIME"
        done
    }

    # Simply calls the status check of a vault, used to check if it is
    # initialized, unsealed, or part of raft cluster
    function vaultServerStatus {
        local tmout=""

        if [ -n "$1" ]; then
            tmout="--connect-timeout $1"
        fi
        curl $tmout --cacert $CERT -s \
            https://$row.$DOMAIN:8200/v1/sys/health
    }

    function runStateMachine {
        local host="$1"
        local dns_name="$2"
        local sealed="$3"
        local VAULT="$dns_name"
        local status_rec
        local old_rec
        local counter

        status_rec="/$host/$dns_name/$sealed/"

        # log compression: do not print logs when status is unchanged
        # omit counter when checking vault server state change
        old_rec="$( grep "$status_rec" "$PODREC_F" )"
        if [ $? -ne 0 ]; then
            log $DEBUG "$( grep "$dns_name" $WORKDIR/pods.txt )"
            log $INFO "Sealed status of $dns_name is now: $sealed"

            # reread the record by hostname only
            old_rec="$( grep "^/$host/" "$PODREC_F" )"
        else
            log $DEBUG "There is no change in pod seal status"
        fi

        if [ "$sealed" != "true" ]; then
            # There is nothing more to do: the vault is unsealed
            # or the sealed status is unclear
            echo "$status_rec" >> "$PODREC_TMP_F"
            return
        fi

        # The vault is sealed
        #
        # Check if there is a countdown in progress
        #
        # else -z old_rec: "the pod didn't have an IP address the last
        # iteration, but now it does" - treat the same as "sealed
        # without a countdown"
        counter=""
        if [ -n "$old_rec" ]; then
            counter="$( echo "$old_rec" | awk -F/ '{print $5}' )"
        fi

        if [ -z "$counter" ]; then
            # sealed without a countdown: start counting
            log $DEBUG "Sealed vault $host: begin unseal delay:" \
                "$( expr "$STATUS_RATE" \* "$STATEMACH_START" )s"
            echo "${status_rec}${STATEMACH_START}" >> "$PODREC_TMP_F"
            return
        fi

        # Check for end of period: 1 means "zero at this interval"
        # "less than 1" for resilience
        if [ "$counter" -le 1 -o "$STATEMACH_START" -eq 0 ]; then
            # We've waited (STATUS_RATE * STATEMACH_START) seconds
            # Or, STATEMACH_START == 0 means do not delay
            log $INFO "Unsealing $dns_name"
            unsealVault
            echo "$status_rec" >> "$PODREC_TMP_F"
            return
        fi

        # finally, continue to countdown
        counter="$( expr "$counter" - 1 )"
        echo "${status_rec}${counter}" >> "$PODREC_TMP_F"
    }

    function vaultInitialized {
        row=$(awk 'NR==1{print $2}' $WORKDIR/pods.txt)
        vaultServerStatus > $WORKDIR/healthcheck.txt
        IS_VAULT_INITIALIZED=$(cat $WORKDIR/healthcheck.txt | jq -r .initialized)
        text="$( grep $row $WORKDIR/pods.txt )"
        if [ $? -eq 0 ]; then
            log $DEBUG "$text"
            log $DEBUG "Initialized status is $IS_VAULT_INITIALIZED"
        fi

        # The empty check is here as a extra safety net, but an investigation into
        # in which exact conditions would IS_VAULT_INITIALIZED be empty would be helpful.
        if [ ! -z $IS_VAULT_INITIALIZED ] && [ $IS_VAULT_INITIALIZED = false ]; then
            return 1
        else
            return 0
        fi
    }

    function set_secret {
        local secret="$1"
        local contentf="$2"

        kubectl create secret generic -n "$VAULT_NS" "$secret" \
            "--from-file=strdata=$contentf"
    }

    function get_secret {
        local secret="$1"

        kubectl get secrets -n "$VAULT_NS" "$secret" \
            -o jsonpath='{.data.strdata}' \
        | base64 -d
    }

    #
    # LOGIC
    #
    exit_on_trap 1

    # Waiting for at least one vault server, to check initialization
    waitForPods 1
    exit_on_trap 2

    log $DEBUG "Putting a list of vault pods and ip in $WORKDIR/pods.txt"
    getVaultPods
    exit_on_trap 3

    vaultInitialized
    IS_VAULT_INITIALIZED=$?
    if [ $IS_VAULT_INITIALIZED -eq 1 ]; then
        exit_on_trap 4
        desired_pods=$HA_REPLICAS

        # Waiting for vault servers to come up
        waitForPods $desired_pods
        exit_on_trap 5

        log $INFO "Putting a list of vault pods and IPs in $WORKDIR/pods.txt"
        getVaultPods
        exit_on_trap 6

        log $DEBUG "Initializing the vault on vault-0 and" \
            "storing keys in persistent storage"
        initVault

        #Some sleep required to allow convergence"
        sleep "$INIT_CONVERGE_TIME"

        log $DEBUG "Unsealing vault-0 using the init shards"
        for row in $(awk 'NR==1{print $2}' $WORKDIR/pods.txt); do
            VAULT=$row
            unsealVault
        done

        log $DEBUG "Joining other vault servers to the HA Raft cluster"
        for row in $(awk 'NR>1{print $2}' $WORKDIR/pods.txt); do
            log $DEBUG "$( grep $row $WORKDIR/pods.txt )"
            joinRaft
            sleep "$JOIN_RATE"
        done

        exit_on_trap 7
        log $INFO "Unsealing the remaining vaults"
        for row in $(awk 'NR>1{print $2}' $WORKDIR/pods.txt); do
            log $DEBUG "$( grep $row $WORKDIR/pods.txt )"
            VAULT=$row
            unsealVault
            sleep "$UNSEAL_RATE"
            exit_on_trap 8
        done
    fi

    exit_on_trap 9
    # initialize the state machine - vault server status records
    echo "" > "$PODREC_F"
    while read host dns_name; do
        if [ -z "$host" ]; then
            continue
        fi
        status_rec="/$host/$dns_name//"
        echo "$status_rec" >> "$PODREC_F"
    done <$WORKDIR/pods.txt

    # Loop forever to check the seal status of vaults and
    # unseal if required
    log $INFO "Checking vault pods seal status in perpetuity..."
    while true; do
        exit_on_trap 10
        sleep "$STATUS_RATE"
        rm $WORKDIR/pods.txt
        echo "" > "$PODREC_TMP_F"
        exit_on_trap 11
        getVaultPods
        exit_on_trap 12
        while read host row; do
            if [ -z "$row" ]; then
                # probably a recovering pod waiting for an IP address
                log $DEBUG "pod list has empty data: [$host] [$row]"
                continue
            fi
            vaultServerStatus $QUERY_TMOUT > $WORKDIR/healthcheck.txt
            TEMP=$(cat $WORKDIR/healthcheck.txt | jq -r .sealed)

            exit_on_trap 13
            # Decide when to unseal the vault server; includes
            # Adding records to new_pods_status.txt
            runStateMachine "$host" "$row" "$TEMP"
            exit_on_trap 14
        done <$WORKDIR/pods.txt
        mv "$PODREC_TMP_F" "$PODREC_F"
    done
kind: ConfigMap
metadata:
  managedFields:
  - apiVersion: v1
    fieldsType: FieldsV1
    fieldsV1:
      f:data:
        .: {}
        f:init.sh: {}
    manager: vault-init-unseal
  name: vault-init-unseal-2
  namespace: {{ .Release.Namespace }}
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: {{ .Release.Namespace }}
  name: {{ template "vault.fullname" . }}-vault-manager
rules:
- apiGroups: [""] # "" indicates the core API group
  resources: ["pods"]
  verbs: ["get", "watch", "list"]
- apiGroups: [""] # "" indicates the core API group
  resources: ["secrets"]
  verbs: ["get", "create"]
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: {{ template "vault.fullname" . }}-vault-manager
  namespace: {{ .Release.Namespace }}
  labels:
    helm.sh/chart: {{ include "vault.chart" . }}
    app.kubernetes.io/name: {{ include "vault.name" . }}-vault-manager
    app.kubernetes.io/instance: {{ .Release.Name }}
    app.kubernetes.io/managed-by: {{ .Release.Service }}
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: {{ template "vault.fullname" . }}-vault-manager
  namespace: {{ .Release.Namespace }}
subjects:
- kind: ServiceAccount
  name: {{ template "vault.fullname" . }}-vault-manager
roleRef:
  kind: Role
  name: {{ template "vault.fullname" . }}-vault-manager
  apiGroup: rbac.authorization.k8s.io
---
{{- if and (eq (.Values.injector.enabled | toString) "true" ) (eq (.Values.global.enabled | toString) "true") }}
# Deployment for the unsealer
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: {{ template "vault.fullname" . }}-manager2
  namespace: {{ .Release.Namespace }}
  labels:
    app.kubernetes.io/name: {{ include "vault.name" . }}-manager
    app.kubernetes.io/instance: {{ .Release.Name }}
    app.kubernetes.io/managed-by: {{ .Release.Service }}
    component: webhook
spec:
  serviceName: {{ template "vault.fullname" . }}
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/instance: {{ .Release.Name }}
      component: webhook
  template:
    metadata:
      labels:
        app.kubernetes.io/name: {{ template "vault.name" . }}-manager
        app.kubernetes.io/instance: {{ .Release.Name }}
        component: webhook
        {{- if  .Values.manager.extraLabels }}
          {{- toYaml .Values.manager.extraLabels | nindent 8 -}}
        {{- end }}
    spec:
      serviceAccountName: "{{ template "vault.fullname" . }}-vault-manager"
      {{- if .Values.global.imagePullSecrets }}
      imagePullSecrets:
        {{- toYaml .Values.global.imagePullSecrets | nindent 8 }}
      {{- end }}
      {{- if .Values.manager.tolerations }}
      tolerations:
        {{- tpl .Values.manager.tolerations . | nindent 8 }}
      {{- end }}
      containers:
        - name: manager
          image: "{{ .Values.manager.image.repository }}:{{ .Values.manager.image.tag }}"
          imagePullPolicy: "{{ .Values.injector.image.pullPolicy }}"
          args:
            - bash
            - /opt/script/init.sh
          env:
          - name: CA_CERT
            value: /mnt/data/ca/tls.crt
          volumeMounts:
            - name: vault-init-unseal-2
              mountPath: /opt/script
              readOnly: false
            - name: vault-ca
              mountPath: /mnt/data/ca
              readOnly: true
      volumes:
        - name: vault-init-unseal-2
          configMap:
            name: vault-init-unseal-2
        - name: vault-ca
          secret:
            secretName: vault-ca
{{ end }}
