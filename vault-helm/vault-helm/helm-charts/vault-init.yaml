apiVersion: v1
data:
  init.sh: |
    #!/bin/bash

    # Get the CA path from environment vars
    CERT=$CA_CERT
    # Store cert as a oneliner for curl purposes
    CA_ONELINE=$(awk '{printf "%s\\n", $0}' $CERT)

    # Set the domain for resolving pod names
    DOMAIN={{ .Release.Namespace }}.pod.cluster.local
    SVCDOMAIN={{ .Release.Namespace }}.svc.cluster.local

    # PVC location so that keys can be persisted
    WORKDIR=$PVCDIR

    # Records for seal status state machine:
    PODREC_F="$WORKDIR/previous_pods_status.txt"
    PODREC_TMP_F="$WORKDIR/new_pods_status.txt"

    # Vault server health query timeout during HA recovery scenario
    QUERY_TMOUT={{ .Values.manager.healthQueryTimeout }}

    STATEFULSET_RATE=5
    INIT_CONVERGE_TIME=10
    JOIN_RATE=5
    JOIN_CONVERGE_TIME=1
    UNSEAL_RATE=10
    UNSEAL_CONVERGE_TIME=3
    STATUS_RATE={{ .Values.manager.statusCheckRate }}
    if [ -z "$STATUS_RATE" ]; then
        STATUS_RATE=5
    fi

    # with STATUS_RATE, the period to delay unseal
    # STATUS_RATE * STATEMACH_START seconds
    STATEMACH_START={{ .Values.manager.unsealWaitIntervals }}
    if [ -z "$STATEMACH_START" ]; then
        STATEMACH_START=3
    fi

    # FUNCTIONS
    function log {
        echo "$(date +%Y-%m-%dT%H-%M-%S)  $@"
    }

    if ! [[ "$QUERY_TMOUT" =~ ^[0-9]+$ ]]; then
        log ".Values.manager.healthQueryTimeout not an integer"
        QUERY_TMOUT=""
    fi

    # Creates a list of all k8s vault pods and stores in text file.
    # Converts ips from X.X.X.X or a:b:c::d to X-X-X-X for use as pod
    # dns names
    function getVaultPods {
        kubectl get pods \
        -n {{ .Release.Namespace }} \
        -l component=server,app.kubernetes.io/name=vault \
        -o=jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.status.podIPs[].ip}{"\n"}{end}' \
        > $WORKDIR/pods.txt

        sed -i 's/\.\|:/-/g' $WORKDIR/pods.txt
    }

    # Wait for the vault servers in the stateful set to be
    # created before initializing
    function waitForPods {
        CURRENT_PODS=$(kubectl get pods \
                    -l component=server,app.kubernetes.io/name=vault \
                    -o=jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.status.podIPs[].ip}{"\t"}{.status.phase}{"\n"} \
                    {end}' \
                    | grep Running \
                    | wc -l)
        DESIRED_PODS={{ .Values.server.ha.replicas }}

        while [ $CURRENT_PODS != $DESIRED_PODS ]; do
            sleep "$STATEFULSET_RATE"
            log "Waiting for {{ template "vault.fullname" . }}" \
                "statefulset running pods ($CURRENT_PODS) to equal" \
                "desired pods ($DESIRED_PODS)"
            CURRENT_PODS=$(kubectl get pods \
                -l component=server,app.kubernetes.io/name=vault \
                -o=jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.status.podIPs[].ip}{"\t"}{.status.phase}{"\n"} \
                {end}' \
                | grep Running \
                | wc -l)
        done
    }

    # Initializes the first vault pod, only needs to be performed once
    # after deploying the helm chart
    # Stores the root token and master key shards in plaintext in
    # working directory as cluster_keys.json - insecure.
    function initVault {
        V0=$(awk 'NR==1{print $2}' $WORKDIR/pods.txt)
        log "Initializing $V0"
        curl -s \
        --cacert $CERT \
        --request POST \
        --data  '{"secret_shares": 5, "secret_threshold": 3}' \
        https://$V0.$DOMAIN:8200/v1/sys/init \
        > $WORKDIR/cluster_keys.json
    }

    # Uses the master key shards in cluster_keys.json to unseal vault
    function unsealVault {
        shards="$(cat $WORKDIR/cluster_keys.json | jq -r .keys_base64[])"
        for shard in $shards; do
            echo {\"key\": \"$shard\"} \
            | curl -s --cacert $CERT --request POST -d @- \
                https://$VAULT.$DOMAIN:8200/v1/sys/unseal > /dev/null
            #Some sleep is required to allow Raft convergence
            sleep "$UNSEAL_CONVERGE_TIME"
        done
    }

    # Takes the address of vault-0 as the cluster leader and
    # joins other nodes to raft
    function joinRaft {
        CLUSTER_LEAD=$(awk 'NR==1{print $2}' $WORKDIR/pods.txt)
        ROOT_TOKEN=$(cat $WORKDIR/cluster_keys.json | jq -r .root_token)
        RAFT_STATUS=""
        while [ "$RAFT_STATUS" != "true" ]; do
            RAFT_STATUS=$(curl -s \
                --cacert $CERT \
                -H "X-Vault-Token: $ROOT_TOKEN" \
                --request POST \
                --data "{\"leader_api_addr\": \"https://sva-{{ template "vault.name" .}}-active.$SVCDOMAIN:8200\", \"leader_ca_cert\": \"$CA_ONELINE\"}" \
                https://$row.$DOMAIN:8200/v1/sys/storage/raft/join)

            log "$row $RAFT_STATUS"
            RAFT_STATUS=$(echo $RAFT_STATUS | jq -r .joined)
            sleep "$JOIN_CONVERGE_TIME"
        done
    }

    # Simply calls the status check of a vault, used to check if it is
    # initialized, unsealed, or part of raft cluster
    function vaultServerStatus {
        local tmout=""

        if [ -n "$1" ]; then
            tmout="--connect-timeout $1"
        fi
        curl $tmout --cacert $CERT -s \
            https://$row.$DOMAIN:8200/v1/sys/health
    }

    function runStateMachine {
        local host="$1"
        local dns_name="$2"
        local sealed="$3"
        local VAULT="$dns_name"
        local status_rec
        local old_rec
        local counter

        status_rec="/$host/$dns_name/$sealed/"

        # log compression: do not print logs when status is unchanged
        # omit counter when checking vault server state change
        old_rec="$( grep "$status_rec" "$PODREC_F" )"
        if [ $? -ne 0 ]; then
            log "$( grep "$dns_name" $WORKDIR/pods.txt )"
            log "Sealed status is now: $sealed"

            # reread the record by hostname only
            old_rec="$( grep "^/$host/" "$PODREC_F" )"
        fi

        if [ "$sealed" != "true" ]; then
            # There is nothing more to do: the vault is unsealed
            # or the sealed status is unclear
            echo "$status_rec" >> "$PODREC_TMP_F"
            return
        fi

        # The vault is sealed
        #
        # Check if there is a countdown in progress
        #
        # else -z old_rec: "the pod didn't have an IP address the last
        # iteration, but now it does" - treat the same as "sealed
        # without a countdown"
        counter=""
        if [ -n "$old_rec" ]; then
            counter="$( echo "$old_rec" | awk -F/ '{print $5}' )"
        fi

        if [ -z "$counter" ]; then
            # sealed without a countdown: start counting
            log "Sealed vault $host: begin unseal delay:" \
                "$( expr "$STATUS_RATE" \* "$STATEMACH_START" )s"
            echo "${status_rec}${STATEMACH_START}" >> "$PODREC_TMP_F"
            return
        fi

        # Check for end of period: 1 means "zero at this interval"
        # "less than 1" for resilience
        if [ "$counter" -le 1 -o "$STATEMACH_START" -eq 0 ]; then
            # We've waited (STATUS_RATE * STATEMACH_START) seconds
            # Or, STATEMACH_START == 0 means do not delay
            log "Unsealing $dns_name"
            unsealVault
            echo "$status_rec" >> "$PODREC_TMP_F"
            return
        fi

        # finally, continue to countdown
        counter="$( expr "$counter" - 1 )"
        echo "${status_rec}${counter}" >> "$PODREC_TMP_F"
    }


    #
    # LOGIC
    #

    # Waiting for vault servers to come up
    waitForPods

    echo ""
    log "Putting a list of vault pods and ip in $WORKDIR/pods.txt"
    getVaultPods

    echo ""
    row=$(awk 'NR==1{print $2}' $WORKDIR/pods.txt)
    vaultServerStatus > $WORKDIR/healthcheck.txt
    TEMP=$(cat $WORKDIR/healthcheck.txt | jq -r .initialized)
    text="$( grep $row $WORKDIR/pods.txt )"
    if [ $? -eq 0 ]; then
        log "$text"
        log "Initialized status is $TEMP"
    fi
    if [ ! -z $TEMP ] && [ $TEMP = false ]; then

        log "Initializing the vault on vault-0 and" \
            "storing keys in $WORKDIR/cluster_keys.json"
        initVault
        cp $WORKDIR/cluster_keys.json $WORKDIR/cluster_init.json
        #Some sleep required to allow convergence"
        sleep "$INIT_CONVERGE_TIME"

        echo ""
        log "Unsealing vault-0 using the init shards"
        for row in $(awk 'NR==1{print $2}' $WORKDIR/pods.txt); do
            VAULT=$row
            unsealVault
        done

        echo ""
        log "Joining other vault servers to the HA Raft cluster"
        for row in $(awk 'NR>1{print $2}' $WORKDIR/pods.txt); do
            log "$( grep $row $WORKDIR/pods.txt )"
            joinRaft
            sleep "$JOIN_RATE"
        done

        echo ""
        log "Unsealing the remaining vaults"
        for row in $(awk 'NR>1{print $2}' $WORKDIR/pods.txt); do
            log "$( grep $row $WORKDIR/pods.txt )"
            VAULT=$row
            unsealVault
            sleep "$UNSEAL_RATE"
        done
    fi

    # initialize the state machine - vault server status records
    echo "" > "$PODREC_F"
    while read host dns_name; do
        if [ -z "$host" ]; then
            continue
        fi
        status_rec="/$host/$dns_name//"
        echo "$status_rec" >> "$PODREC_F"
    done <$WORKDIR/pods.txt

    # Loop forever to check the seal status of vaults and
    # unseal if required
    log "Checking vault pods seal status in perpetuity..."
    while true; do
        sleep "$STATUS_RATE"
        rm $WORKDIR/pods.txt
        echo "" > "$PODREC_TMP_F"
        getVaultPods
        while read host row; do
            if [ -z "$row" ]; then
                # probably a recovering pod waiting for an IP address
                log "pod list has empty data: [$host] [$row]"
                continue
            fi
            vaultServerStatus $QUERY_TMOUT > $WORKDIR/healthcheck.txt
            TEMP=$(cat $WORKDIR/healthcheck.txt | jq -r .sealed)

            # Decide when to unseal the vault server; includes
            # Adding records to new_pods_status.txt
            runStateMachine "$host" "$row" "$TEMP"
        done <$WORKDIR/pods.txt
        mv "$PODREC_TMP_F" "$PODREC_F"
    done
kind: ConfigMap
metadata:
  managedFields:
  - apiVersion: v1
    fieldsType: FieldsV1
    fieldsV1:
      f:data:
        .: {}
        f:init.sh: {}
    manager: vault-init-unseal
  name: vault-init-unseal
  namespace: {{ .Release.Namespace }}
---
{{- if and (eq (.Values.injector.enabled | toString) "true" ) (eq (.Values.global.enabled | toString) "true") }}
# Deployment for the unsealer
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: {{ template "vault.fullname" . }}-manager
  namespace: {{ .Release.Namespace }}
  labels:
    app.kubernetes.io/name: {{ include "vault.name" . }}-manager
    app.kubernetes.io/instance: {{ .Release.Name }}
    app.kubernetes.io/managed-by: {{ .Release.Service }}
    component: webhook
spec:
  serviceName: {{ template "vault.fullname" . }}
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/instance: {{ .Release.Name }}
      component: webhook
  template:
    metadata:
      labels:
        app.kubernetes.io/name: {{ template "vault.name" . }}-manager
        app.kubernetes.io/instance: {{ .Release.Name }}
        component: webhook
    spec:
      serviceAccountName: "{{ template "vault.fullname" . }}"
      {{- if .Values.global.imagePullSecrets }}
      imagePullSecrets:
        {{- toYaml .Values.global.imagePullSecrets | nindent 8 }}
      {{- end }}
      {{- if .Values.manager.tolerations }}
      tolerations:
        {{- tpl .Values.manager.tolerations . | nindent 8 }}
      {{- end }}
      containers:
        - name: manager
          image: "{{ .Values.manager.image.repository }}:{{ .Values.manager.image.tag }}"
          imagePullPolicy: "{{ .Values.injector.image.pullPolicy }}"
          args:
            - bash
            - /opt/script/init.sh
          env:
          - name: PVCDIR
            value: /mnt/data
          - name: CA_CERT
            value: /mnt/data/ca/tls.crt
          volumeMounts:
            - name: vault-init-unseal
              mountPath: /opt/script
              readOnly: false
            - name: manager-pvc
              mountPath: /mnt/data
              readOnly: false
            - name: vault-ca
              mountPath: /mnt/data/ca
              readOnly: true
      volumes:
        - name: vault-init-unseal
          configMap:
            name: vault-init-unseal
        - name: vault-ca
          secret:
            secretName: vault-ca
  volumeClaimTemplates:
    - metadata:
        name: manager-pvc
      spec:
        accessModes:
          - ReadWriteOnce
        resources:
          requests:
            storage: 1Gi
{{ end }}
